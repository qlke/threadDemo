# threadDemo
## 创建线程的几种方法
### 继承Thread类
其实Thread类也是实现的Runnable接口的
### 实现Runnable接口
学习多线程过程中的一些详细示例
## 线程间通信常用的一些方法
### wait
- 在当前线程中调用方法： 对象名.wait()
- 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。
- 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）。
- 调用此方法后，当前线程将释放对象监控权 ，也就是释放当前的锁，然后进入等待。
- 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。
### notify/notifyAll
- 在当前线程中调用方法： 对象名.notify()。
- 功能：唤醒等待该对象监控权的一个/所有线程。唤醒正在排队等待同步资源的线程中优先级最高者结束等待/唤醒正在排队等待资源的所有线程结束等待.
- 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）。
### sleep
wait和sleep的异同?
- 都可以使当前的线程进入到阻塞状态。
#### 不同点：
1. 两个方法声明的位置不同，sleep是在Thread类中声明的，而wait是在Object类中声明的。
2. 调用的范围不同，sleep()可以在任何需要的场景下调用，wait()必须在同步代码块或同步方法中调用。
3. 关于是否释放同步监视器：如果两个方法都是使用在同步代码块中，那么sleep()方法不会释放锁，而wait()方法会释放锁。

